# 时基单元

假设我们现在有一个数据需要每200ms更新一次，那么就要开启一个200ms为周期的计时器，首先我们得知道这200ms怎么数出来的，其实就是对芯片时钟脉冲进行计数，而这个芯片振荡又是由内外部晶震动或RC电路产生的不同的芯片和电路程序配置都会有不同的时钟，此部分内容还请详见[RCC时钟系统]()，这里不再赘述。

回到正题，我们知道了芯片的时钟频率后，算出200ｍs对应的脉冲数，把它用预分频和预装载值来表示，具体公式为脉冲数=预分频*预装载，而预分频其实是一个系数，就是它把相当大的脉冲数分解为了装载值的倍数，可以说，有了合理的预分频值，我们便可以轻松在一长串的脉冲数与预装载值之间转化了

> P.S.：因为对于时钟脉冲数来说，预装载和预分频是乘数与被乘数的关系，有的人会觉得反正其乘积是一样的，从而随意分配预分频值。此举咋一看似乎未尝不可，但仔细一想就能发现系数的变化会导致精确值的计算变得困难，糟蹋了设计者的一番好意，长远看还影响了其他功能的工作精度，实则是不可取的方式

讲完计数器的原理，就是计数模式了，它决定了这个计时器是正常计时、倒计时还是都沾点，各个计数模式根据不同情况下能发挥奇效，不过这就要自己去摸索了，一般情况为了方便我们用的是向上计数

现在我们再来思考这样一个问题：当达到规定的计数值后，会发生什么呢？答案是：在使定时计数器更新的下一个脉冲即将到来时，计数器将完成**计数器溢出**、**产生更新事件**（可被禁止或选择更新）、**硬件置位中断标志**的一系列动作

而我们开启定时器的目的，不正是为了获得计时时间嘛！得益于STM32设计的自由度，我们可以选择在溢出后通过中断立马进入对应服务函数进行处理，也可以选择关闭中断而不处理，具体情况具体处理咯

需要注意的是，每个时钟都有器对应固定的中断函数，原理类似于51的中断号，更多内容请在[NVIC中断]()，不同之处在于STM32位是必须软件复位的

话说回来，有预分频寄存器，有没有其它的呢？还真有，它就是时钟分频因子，这个分频因子直接对时钟脉冲分频，根据设置改变对脉冲的采样数，例如将1脉冲有效变为4脉冲，从而达到硬件消抖/延长总计时时间等目的

至于计时溢出的中断响应也是可以进行延后的，这种方法叫重复计数，就是规定计数器重复溢出多少次才能产生一个中断



> 也可以用软件程序去查询计数溢出的信号，区别就在于是立即响应还是延后了(只存在1个周期，实际上不成立，更适用于51)

> 看来，当我们想立即进行相关的处理时，既可以直接调用处理函数，也可以将溢出标志位软件置高，同时还会获得中断响应的优先级哦，相当鸡贼
